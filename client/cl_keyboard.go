/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
 * USA.
 *
 * =======================================================================
 *
 * Upper layer of the keyboard implementation. This file processes all
 * keyboard events which are generated by the low level keyboard layer.
 * Remeber, that the mouse is handled by the refresher and not by the
 * client!
 *
 * =======================================================================
 */
package client

import (
	"strings"
)

/*
 * Returns a key number to be used to index
 * keybindings[] by looking at the given string.
 * Single ascii characters return themselves, while
 * the K_* names are matched up.
 */
func keyStringToKeynum(str string) int {

	if len(str) == 0 {
		return -1
	}

	if len(str) == 1 {
		return int(str[0])
	}

	for _, kn := range keynames {
		if str == kn.name {
			return kn.keynum
		}
	}

	return -1
}

func (T *qClient) keySetBinding(keynum int, binding string) {
	if keynum == -1 {
		return
	}

	T.keybindings[keynum] = string(binding)
}

func key_Bind_f(args []string, a interface{}) error {
	T := a.(*qClient)

	if len(args) < 2 {
		T.common.Com_Printf("bind <key> [command] : attach a command to a key\n")
		return nil
	}

	b := keyStringToKeynum(args[1])

	if b == -1 {
		T.common.Com_Printf("\"%s\" isn't a valid key\n", args[1])
		return nil
	}

	/* don't allow binding escape or the special console keys */
	if b == K_ESCAPE || b == '^' || b == '`' || b == '~' || b == K_JOY_BACK {
		// if doneWithDefaultCfg {
		/* don't warn about this when it's from default.cfg, we can't change that anyway */
		T.common.Com_Printf("You can't bind the special key \"%s\"!\n", args[1])
		// }
		return nil
	}

	if len(args) == 2 {
		if len(T.keybindings[b]) > 0 {
			T.common.Com_Printf("\"%s\" = \"%s\"\n", args[1], T.keybindings[b])
		} else {
			T.common.Com_Printf("\"%s\" is not bound\n", args[1])
		}

		return nil
	}

	/* copy the rest of the command line */
	var cmd strings.Builder /* start out with a null string */

	for i := 2; i < len(args); i++ {
		cmd.WriteString(args[i])

		if i != (len(args) - 1) {
			cmd.WriteRune(' ')
		}
	}

	T.keySetBinding(b, cmd.String())
	return nil
}

func key_Unbindall_f(args []string, a interface{}) error {

	T := a.(*qClient)

	for i := 0; i < K_LAST; i++ {
		if len(T.keybindings[i]) > 0 {
			T.keySetBinding(i, "")
		}
	}
	return nil
}

func (T *qClient) KeyInit() {

	for i := 0; i < NUM_KEY_LINES; i++ {
		T.key_lines[i] = "]"
	}
	// can't call Key_ReadConsoleHistory() here because FS_Gamedir() isn't set yet

	T.key_linepos = 1

	/* init 128 bit ascii characters in console mode */
	for i := 32; i < 128; i++ {
		T.consolekeys[i] = true
	}

	T.consolekeys[K_ENTER] = true
	T.consolekeys[K_KP_ENTER] = true
	T.consolekeys[K_TAB] = true
	T.consolekeys[K_LEFTARROW] = true
	T.consolekeys[K_KP_LEFTARROW] = true
	T.consolekeys[K_RIGHTARROW] = true
	T.consolekeys[K_KP_RIGHTARROW] = true
	T.consolekeys[K_UPARROW] = true
	T.consolekeys[K_KP_UPARROW] = true
	T.consolekeys[K_DOWNARROW] = true
	T.consolekeys[K_KP_DOWNARROW] = true
	T.consolekeys[K_BACKSPACE] = true
	T.consolekeys[K_HOME] = true
	T.consolekeys[K_KP_HOME] = true
	T.consolekeys[K_END] = true
	T.consolekeys[K_KP_END] = true
	T.consolekeys[K_PGUP] = true
	T.consolekeys[K_KP_PGUP] = true
	T.consolekeys[K_PGDN] = true
	T.consolekeys[K_KP_PGDN] = true
	T.consolekeys[K_SHIFT] = true
	T.consolekeys[K_INS] = true
	T.consolekeys[K_KP_INS] = true
	T.consolekeys[K_KP_DEL] = true
	T.consolekeys[K_KP_SLASH] = true
	T.consolekeys[K_KP_STAR] = true
	T.consolekeys[K_KP_PLUS] = true
	T.consolekeys[K_KP_MINUS] = true
	T.consolekeys[K_KP_5] = true
	T.consolekeys[K_MWHEELUP] = true
	T.consolekeys[K_MWHEELDOWN] = true
	T.consolekeys[K_MOUSE4] = true
	T.consolekeys[K_MOUSE5] = true

	T.consolekeys['`'] = false
	T.consolekeys['~'] = false
	T.consolekeys['^'] = false

	T.menubound[K_ESCAPE] = true

	for i := 0; i < 12; i++ {
		T.menubound[K_F1+i] = true
	}

	/* register our variables */
	// T.cfg_unbindall = common.Cvar_Get("cfg_unbindall", "1", shared.CVAR_ARCHIVE)

	/* register our functions */
	T.common.Cmd_AddCommand("bind", key_Bind_f, T)
	// common.Cmd_AddCommand("unbind", Key_Unbind_f)
	T.common.Cmd_AddCommand("unbindall", key_Unbindall_f, T)
	// common.Cmd_AddCommand("bindlist", Key_Bindlist_f)
}

/*
 * Called every frame for every detected keypress.
 * This is only for movement and special characters,
 * anything else is handled by Char_Event().
 */
func (T *qClient) KeyEvent(key int, down, special bool) {
	// char cmd[1024];
	// char *kb;
	// cvar_t *fullscreen;
	// unsigned int time = Sys_Milliseconds();

	// // evil hack for the joystick key altselector, which turns K_JOYx into K_JOYx_ALT
	// if(joy_altselector_pressed && key >= K_JOY1 && key <= K_JOY_LAST_REGULAR)
	// {
	// 	// make sure key is not the altselector itself (which we won't turn into *_ALT)
	// 	if(keybindings[key] == NULL || strcmp(keybindings[key], "+joyaltselector") != 0)
	// 	{
	// 		int altkey = key + (K_JOY1_ALT - K_JOY1);
	// 		// allow fallback to binding with non-alt key
	// 		if(keybindings[altkey] != NULL || keybindings[key] == NULL)
	// 			key = altkey;
	// 	}
	// }

	/* Track if key is down */
	T.keydown[key] = down

	// /* Evil hack against spurious cinematic aborts. */
	// if (down && (key != K_ESCAPE) && !keydown[K_SHIFT])
	// {
	// 	abort_cinematic = cls.realtime;
	// }

	// /* Ignore most autorepeats */
	if down {
		T.key_repeats[key]++

		if (key != K_BACKSPACE) &&
			(key != K_PAUSE) &&
			(key != K_PGUP) &&
			(key != K_KP_PGUP) &&
			(key != K_PGDN) &&
			(key != K_KP_PGDN) &&
			(T.key_repeats[key] > 1) {
			return
		}
	} else {
		T.key_repeats[key] = 0
	}

	/* Fullscreen switch through Alt + Return */
	// if (down && keydown[K_ALT] && key == K_ENTER)
	// {
	// 	fullscreen = Cvar_Get("vid_fullscreen", "0", CVAR_ARCHIVE);

	// 	if (!fullscreen->value)
	// 	{
	// 		Cvar_Set("vid_fullscreen", "1");
	// 		fullscreen->modified = true;
	// 	}
	// 	else
	// 	{
	// 		Cvar_Set("vid_fullscreen", "0");
	// 		fullscreen->modified = true;
	// 	}

	// 	return;
	// }

	// /* Toogle console through Shift + Escape or special K_CONSOLE key */
	// if (key == K_CONSOLE || (keydown[K_SHIFT] && key == K_ESCAPE))
	// {
	// 	if (down)
	// 	{
	// 		Con_ToggleConsole_f();
	// 	}
	// 	return;
	// }

	// /* Key is unbound */
	// if ((key >= K_MOUSE1 && key != K_JOY_BACK) && !keybindings[key] && (cls.key_dest != key_console) &&
	// 	(cls.state == ca_active))
	// {
	// 	Com_Printf("%s (%d) is unbound, hit F4 to set.\n", Key_KeynumToString(key), key);
	// }

	/* While in attract loop all keys besides F1 to F12 (to
	   allow quick load and the like) are treated like escape. */
	if T.cl.attractloop && (T.cls.key_dest != key_menu) &&
		!((key >= K_F1) && (key <= K_F12)) {
		key = K_ESCAPE
	}

	/* Escape has a special meaning. Depending on the situation it
	   - pauses the game and breaks into the menu
	   - stops the attract loop and breaks into the menu
	   - closes the console and breaks into the menu
	   - moves one menu level up
	   - closes the menu
	   - closes the help computer
	   - closes the chat window
	   Fully same logic for K_JOY_BACK */
	if T.cls.disable_screen == 0 {
		if key == K_ESCAPE || key == K_JOY_BACK {
			if !down {
				return
			}

			// 		/* Close the help computer */
			// 		if (cl.frame.playerstate.stats[STAT_LAYOUTS] &&
			// 			(cls.key_dest == key_game)) {
			// 			Cbuf_AddText("cmd putaway\n");
			// 			return;
			// 		}

			switch T.cls.key_dest {
			// 			/* Close chat window */
			// 			case key_message:
			// 				Key_Message(key);

			/* Close menu or one layer up */
			case key_menu:
				T.mKeydown(key)

			/* Pause game and / or leave console,
			   break into the menu. */
			case key_game,
				key_console:
				m_Menu_Main_f([]string{}, T)
			}

			return
		}
	}

	/* This is one of the most ugly constructs I've
	   found so far in Quake II. When the game is in
	   the intermission, the player can press any key
	   to end it and advance into the next level. It
	   should be easy to figure out at server level if
	   a button is pressed. But somehow the developers
	   decided, that they'll need special move state
	   BUTTON_ANY to solve this problem. So there's
	   this global variable anykeydown. If it's not
	   0, CL_FinishMove() encodes BUTTON_ANY into the
	   button state. The server reads this value and
	   sends it to gi->ClientThink() where it's used
	   to determine if the intermission shall end.
	   Needless to say that this is the only consumer
	   of BUTTON_ANY.

	   Since we cannot alter the network protocol nor
	   the server <-> game API, I'll leave things alone
	   and try to forget. */
	if down {
		if T.key_repeats[key] == 1 {
			T.anykeydown++
		}
	} else {
		T.anykeydown--

		if T.anykeydown < 0 {
			T.anykeydown = 0
		}
	}

	/* key up events only generate commands if the game key binding
	   is a button command (leading+ sign). These will occur even in
	   console mode, to keep the character from continuing an action
	   started before a console switch. Button commands include the
	   kenum as a parameter, so multiple downs can be matched with ups */
	if !down {
		// 	kb = keybindings[key];

		// 	if (kb && (kb[0] == '+'))
		// 	{
		// 		Com_sprintf(cmd, sizeof(cmd), "-%s %i %i\n", kb + 1, key, time);
		// 		Cbuf_AddText(cmd);
		// 	}

		return
	} else if ((T.cls.key_dest == key_menu) && T.menubound[key]) ||
		((T.cls.key_dest == key_console) && !T.consolekeys[key]) ||
		((T.cls.key_dest == key_game) && ((T.cls.state == ca_active) ||
			!T.consolekeys[key])) {
		// 	kb = keybindings[key];

		// 	if (kb) {
		// 		if (kb[0] == '+') {
		// 			/* button commands add keynum and time as a parm */
		// 			Com_sprintf(cmd, sizeof(cmd), "%s %i %i\n", kb, key, time);
		// 			Cbuf_AddText(cmd);
		// 		}
		// 		else
		// 		{
		// 			Cbuf_AddText(kb);
		// 			Cbuf_AddText("\n");
		// 		}
		// 	}

		return
	}

	/* All input subsystems handled after this point only
	   care for key down events (=> if(!down) returns above). */

	/* Everything that's not a special char
	   is processed by Char_Event(). */
	if !special {
		return
	}

	/* Send key to the active input subsystem */
	switch T.cls.key_dest {
	// 	/* Chat */
	// 	case key_message:
	// 		Key_Message(key);
	// 		break;

	/* Menu */
	case key_menu:
		T.mKeydown(key)

		// 	/* Console */
		// 	case key_game:
		// 	case key_console:
		// 		Key_Console(key);
		// 		break;
	}
}

type keyname_t struct {
	name   string
	keynum int
}

/* Translates internal key representations
 * into human readable strings. */
var keynames = []keyname_t{
	{"TAB", K_TAB},
	{"ENTER", K_ENTER},
	{"ESCAPE", K_ESCAPE},
	{"SPACE", K_SPACE},
	{"SEMICOLON", ';'},   /* because a raw semicolon separates commands */
	{"DOUBLEQUOTE", '"'}, /* because "" has special meaning in configs */
	{"QUOTE", '\''},      /* just to be sure */
	{"DOLLAR", '$'},      /* $ is used in macros => can occur in configs */
	{"BACKSPACE", K_BACKSPACE},

	{"COMMAND", K_COMMAND},
	{"CAPSLOCK", K_CAPSLOCK},
	{"POWER", K_POWER},
	{"PAUSE", K_PAUSE},

	{"UPARROW", K_UPARROW},
	{"DOWNARROW", K_DOWNARROW},
	{"LEFTARROW", K_LEFTARROW},
	{"RIGHTARROW", K_RIGHTARROW},

	{"ALT", K_ALT},
	{"CTRL", K_CTRL},
	{"SHIFT", K_SHIFT},

	{"INS", K_INS},
	{"DEL", K_DEL},
	{"PGDN", K_PGDN},
	{"PGUP", K_PGUP},
	{"HOME", K_HOME},
	{"END", K_END},

	{"F1", K_F1},
	{"F2", K_F2},
	{"F3", K_F3},
	{"F4", K_F4},
	{"F5", K_F5},
	{"F6", K_F6},
	{"F7", K_F7},
	{"F8", K_F8},
	{"F9", K_F9},
	{"F10", K_F10},
	{"F11", K_F11},
	{"F12", K_F12},
	{"F13", K_F13},
	{"F14", K_F14},
	{"F15", K_F15},

	{"KP_HOME", K_KP_HOME},
	{"KP_UPARROW", K_KP_UPARROW},
	{"KP_PGUP", K_KP_PGUP},
	{"KP_LEFTARROW", K_KP_LEFTARROW},
	{"KP_5", K_KP_5},
	{"KP_RIGHTARROW", K_KP_RIGHTARROW},
	{"KP_END", K_KP_END},
	{"KP_DOWNARROW", K_KP_DOWNARROW},
	{"KP_PGDN", K_KP_PGDN},
	{"KP_ENTER", K_KP_ENTER},
	{"KP_INS", K_KP_INS},
	{"KP_DEL", K_KP_DEL},
	{"KP_SLASH", K_KP_SLASH},
	{"KP_MINUS", K_KP_MINUS},
	{"KP_PLUS", K_KP_PLUS},
	{"KP_NUMLOCK", K_KP_NUMLOCK},
	{"KP_STAR", K_KP_STAR},
	{"KP_EQUALS", K_KP_EQUALS},

	{"MOUSE1", K_MOUSE1},
	{"MOUSE2", K_MOUSE2},
	{"MOUSE3", K_MOUSE3},
	{"MOUSE4", K_MOUSE4},
	{"MOUSE5", K_MOUSE5},

	{"MWHEELUP", K_MWHEELUP},
	{"MWHEELDOWN", K_MWHEELDOWN},

	{"JOY1", K_JOY1},
	{"JOY2", K_JOY2},
	{"JOY3", K_JOY3},
	{"JOY4", K_JOY4},
	{"JOY5", K_JOY5},
	{"JOY6", K_JOY6},
	{"JOY7", K_JOY7},
	{"JOY8", K_JOY8},
	{"JOY9", K_JOY9},
	{"JOY10", K_JOY10},
	{"JOY11", K_JOY11},
	{"JOY12", K_JOY12},
	{"JOY13", K_JOY13},
	{"JOY14", K_JOY14},
	{"JOY15", K_JOY15},
	{"JOY16", K_JOY16},
	{"JOY17", K_JOY17},
	{"JOY18", K_JOY18},
	{"JOY19", K_JOY19},
	{"JOY20", K_JOY20},
	{"JOY21", K_JOY21},
	{"JOY22", K_JOY22},
	{"JOY23", K_JOY23},
	{"JOY24", K_JOY24},
	{"JOY25", K_JOY25},
	{"JOY26", K_JOY26},
	{"JOY27", K_JOY27},
	{"JOY28", K_JOY28},
	{"JOY29", K_JOY29},
	{"JOY30", K_JOY30},
	{"JOY31", K_JOY31},
	{"JOY32", K_JOY32},

	{"HAT_UP", K_HAT_UP},
	{"HAT_RIGHT", K_HAT_RIGHT},
	{"HAT_DOWN", K_HAT_DOWN},
	{"HAT_LEFT", K_HAT_LEFT},

	{"TRIG_LEFT", K_TRIG_LEFT},
	{"TRIG_RIGHT", K_TRIG_RIGHT},

	// virtual keys you get by pressing the corresponding normal joy key
	// and the altselector key
	{"JOY1_ALT", K_JOY1_ALT},
	{"JOY2_ALT", K_JOY2_ALT},
	{"JOY3_ALT", K_JOY3_ALT},
	{"JOY4_ALT", K_JOY4_ALT},
	{"JOY5_ALT", K_JOY5_ALT},
	{"JOY6_ALT", K_JOY6_ALT},
	{"JOY7_ALT", K_JOY7_ALT},
	{"JOY8_ALT", K_JOY8_ALT},
	{"JOY9_ALT", K_JOY9_ALT},
	{"JOY10_ALT", K_JOY10_ALT},
	{"JOY11_ALT", K_JOY11_ALT},
	{"JOY12_ALT", K_JOY12_ALT},
	{"JOY13_ALT", K_JOY13_ALT},
	{"JOY14_ALT", K_JOY14_ALT},
	{"JOY15_ALT", K_JOY15_ALT},
	{"JOY16_ALT", K_JOY16_ALT},
	{"JOY17_ALT", K_JOY17_ALT},
	{"JOY18_ALT", K_JOY18_ALT},
	{"JOY19_ALT", K_JOY19_ALT},
	{"JOY20_ALT", K_JOY20_ALT},
	{"JOY21_ALT", K_JOY21_ALT},
	{"JOY22_ALT", K_JOY22_ALT},
	{"JOY23_ALT", K_JOY23_ALT},
	{"JOY24_ALT", K_JOY24_ALT},
	{"JOY25_ALT", K_JOY25_ALT},
	{"JOY26_ALT", K_JOY26_ALT},
	{"JOY27_ALT", K_JOY27_ALT},
	{"JOY28_ALT", K_JOY28_ALT},
	{"JOY29_ALT", K_JOY29_ALT},
	{"JOY30_ALT", K_JOY30_ALT},
	{"JOY31_ALT", K_JOY31_ALT},
	{"JOY32_ALT", K_JOY32_ALT},

	{"HAT_UP_ALT", K_HAT_UP_ALT},
	{"HAT_RIGHT_ALT", K_HAT_RIGHT_ALT},
	{"HAT_DOWN_ALT", K_HAT_DOWN_ALT},
	{"HAT_LEFT_ALT", K_HAT_LEFT_ALT},

	{"TRIG_LEFT", K_TRIG_LEFT_ALT},
	{"TRIG_RIGHT", K_TRIG_RIGHT_ALT},

	{"JOY_BACK", K_JOY_BACK},

	{"SUPER", K_SUPER},
	{"COMPOSE", K_COMPOSE},
	{"MODE", K_MODE},
	{"HELP", K_HELP},
	{"PRINT", K_PRINT},
	{"SYSREQ", K_SYSREQ},
	{"SCROLLOCK", K_SCROLLOCK},
	{"MENU", K_MENU},
	{"UNDO", K_UNDO},

	// entries for the mapped scancodes, see comment above K_SC_A in keyboard.h
	// #define MY_SC_ENTRY(X) { #X , K_ ## X }

	// { "SC_A", K_SC_A },
	{"SC_A", K_SC_A},
	{"SC_B", K_SC_B},
	{"SC_C", K_SC_C},
	{"SC_D", K_SC_D},
	// 	{"SC_E),
	// 	{"SC_F),
	// 	{"SC_G),
	// 	{"SC_H),
	// 	{"SC_I),
	// 	{"SC_J),
	// 	{"SC_K),
	// 	{"SC_L),
	// 	{"SC_M),
	// 	{"SC_N),
	// 	{"SC_O),
	// 	{"SC_P),
	// 	{"SC_Q),
	// 	{"SC_R),
	// 	{"SC_S),
	// 	{"SC_T),
	// 	{"SC_U),
	// 	{"SC_V),
	// 	{"SC_W),
	// 	{"SC_X),
	// 	{"SC_Y),
	// 	{"SC_Z),
	// 	{"SC_MINUS),
	// 	{"SC_EQUALS),
	// 	{"SC_LEFTBRACKET),
	// 	{"SC_RIGHTBRACKET),
	// 	{"SC_BACKSLASH),
	// 	{"SC_NONUSHASH),
	// 	{"SC_SEMICOLON),
	// 	{"SC_APOSTROPHE),
	// 	{"SC_GRAVE), // console key
	// 	{"SC_COMMA),
	// 	{"SC_PERIOD),
	// 	{"SC_SLASH),
	// 	{"SC_NONUSBACKSLASH),
	// 	{"SC_INTERNATIONAL1),
	// 	{"SC_INTERNATIONAL2),
	// 	{"SC_INTERNATIONAL3),
	// 	{"SC_INTERNATIONAL4),
	// 	{"SC_INTERNATIONAL5),
	// 	{"SC_INTERNATIONAL6),
	// 	{"SC_INTERNATIONAL7),
	// 	{"SC_INTERNATIONAL8),
	// 	{"SC_INTERNATIONAL9),
	// 	{"SC_THOUSANDSSEPARATOR),
	// 	{"SC_DECIMALSEPARATOR),
	// 	{"SC_CURRENCYUNIT),
	// 	{"SC_CURRENCYSUBUNIT),

	// #undef MY_SC_ENTRY

}
