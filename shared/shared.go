/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * =======================================================================
 *
 * This is the main header file shared between client, renderer, server
 * and the game. Do NOT edit this file unless you know what you're
 * doing. Changes here may break the client <-> renderer <-> server
 * <-> game API, leading to problems with mods!
 *
 * =======================================================================
 */
package shared

import (
	"math"
	"math/rand"
	"strconv"
	"strings"
)

const (
	/* angle indexes */
	PITCH = 0 /* up / down */
	YAW   = 1 /* left / right */
	ROLL  = 2 /* fall over */

	/* per-level limits */
	MAX_CLIENTS     = 256  /* absolute limit */
	MAX_EDICTS      = 1024 /* must change protocol to increase more */
	MAX_LIGHTSTYLES = 256
	MAX_MODELS      = 256 /* these are sent over the net as bytes */
	MAX_SOUNDS      = 256 /* so they cannot be blindly increased */
	MAX_IMAGES      = 256
	MAX_ITEMS       = 256
	MAX_GENERAL     = (MAX_CLIENTS * 2) /* general config strings */

	ERR_FATAL      = 0 /* exit the entire game with a popup window */
	ERR_DROP       = 1 /* print to console and disconnect from game */
	ERR_DISCONNECT = 2 /* don't kill server */

	PRINT_ALL       = 0
	PRINT_DEVELOPER = 1 /* only print when "developer 1" */
	PRINT_ALERT     = 2
)

/*
 * ==========================================================
 *
 * CVARS (console variables)
 *
 * ==========================================================
 */

const (
	CVAR_ARCHIVE    = 1 /* set to cause it to be saved to vars.rc */
	CVAR_USERINFO   = 2 /* added to userinfo  when changed */
	CVAR_SERVERINFO = 4 /* added to serverinfo when changed */
	CVAR_NOSET      = 8 /* don't allow change from console at all, */
	/* but can be set from the command line */
	CVAR_LATCH = 16 /* save changes until server restart */
)

/* nothing outside the Cvar_*() functions should modify these fields! */
type CvarT struct {
	Name          string
	String        string
	LatchedString *string /* for CVAR_LATCH vars */
	Flags         int
	Modified      bool /* set each time the cvar is changed */
	/* Added by YQ2. Must be at the end to preserve ABI. */
	DefaultString string
}

/* pmove_state_t is the information necessary for client side movement */
/* prediction */
type Pmtype_t int

const (
	/* can accelerate and turn */
	PM_NORMAL    Pmtype_t = 0
	PM_SPECTATOR Pmtype_t = 1
	/* no acceleration or turning */
	PM_DEAD   Pmtype_t = 2
	PM_GIB    Pmtype_t = 3 /* different bounding box */
	PM_FREEZE Pmtype_t = 4
)

/* pmove->pm_flags */
const (
	PMF_DUCKED         = 1
	PMF_JUMP_HELD      = 2
	PMF_ON_GROUND      = 4
	PMF_TIME_WATERJUMP = 8  /* pm_time is waterjump */
	PMF_TIME_LAND      = 16 /* pm_time is time before rejump */
	PMF_TIME_TELEPORT  = 32 /* pm_time is non-moving time */
	PMF_NO_PREDICTION  = 64 /* temporarily disables prediction (used for grappling hook) */
)

/* this structure needs to be communicated bit-accurate/
 * from the server to the client to guarantee that
 * prediction stays in sync, so no floats are used.
 * if any part of the game code modifies this struct, it
 * will result in a prediction error of some degree. */
type Pmove_state_t struct {
	Pm_type Pmtype_t

	Origin       [3]int16 /* 12.3 */
	Velocity     [3]int16 /* 12.3 */
	Pm_flags     uint8    /* ducked, jump_held, etc */
	Pm_time      uint8    /* each unit = 8 ms */
	Gravity      int16
	Delta_angles [3]int16 /* add to command angles to get view direction
	 * changed by spawns, rotating objects, and teleporters */
}

func (T *Pmove_state_t) Copy(other Pmove_state_t) {
	T.Pm_type = other.Pm_type
	for i := 0; i < 3; i++ {
		T.Origin[i] = other.Origin[i]
		T.Velocity[i] = other.Velocity[i]
		T.Delta_angles[i] = other.Delta_angles[i]
	}
	T.Pm_flags = other.Pm_flags
	T.Pm_time = other.Pm_time
	T.Gravity = other.Gravity
}

const (
	SPLASH_UNKNOWN     = 0
	SPLASH_SPARKS      = 1
	SPLASH_BLUE_WATER  = 2
	SPLASH_BROWN_WATER = 3
	SPLASH_SLIME       = 4
	SPLASH_LAVA        = 5
	SPLASH_BLOOD       = 6

	/* sound channels:
	 * channel 0 never willingly overrides
	 * other channels (1-7) allways override
	 * a playing sound on that channel */
	CHAN_AUTO   = 0
	CHAN_WEAPON = 1
	CHAN_VOICE  = 2
	CHAN_ITEM   = 3
	CHAN_BODY   = 4
	/* modifier flags */
	CHAN_NO_PHS_ADD = 8  /* send to all clients, not just ones in PHS (ATTN 0 will also do this) */
	CHAN_RELIABLE   = 16 /* send by reliable message, not datagram */

	/* sound attenuation values */
	ATTN_NONE   = 0 /* full volume the entire level */
	ATTN_NORM   = 1
	ATTN_IDLE   = 2
	ATTN_STATIC = 3 /* diminish very rapidly with distance */

	/* player_state->stats[] indexes */
	STAT_HEALTH_ICON   = 0
	STAT_HEALTH        = 1
	STAT_AMMO_ICON     = 2
	STAT_AMMO          = 3
	STAT_ARMOR_ICON    = 4
	STAT_ARMOR         = 5
	STAT_SELECTED_ICON = 6
	STAT_PICKUP_ICON   = 7
	STAT_PICKUP_STRING = 8
	STAT_TIMER_ICON    = 9
	STAT_TIMER         = 10
	STAT_HELPICON      = 11
	STAT_SELECTED_ITEM = 12
	STAT_LAYOUTS       = 13
	STAT_FRAGS         = 14
	STAT_FLASHES       = 15 /* cleared each frame, 1 = health, 2 = armor */
	STAT_CHASE         = 16
	STAT_SPECTATOR     = 17

	MAX_STATS = 32

	/* dmflags->value flags */
	DF_NO_HEALTH        = 0x00000001 /* 1 */
	DF_NO_ITEMS         = 0x00000002 /* 2 */
	DF_WEAPONS_STAY     = 0x00000004 /* 4 */
	DF_NO_FALLING       = 0x00000008 /* 8 */
	DF_INSTANT_ITEMS    = 0x00000010 /* 16 */
	DF_SAME_LEVEL       = 0x00000020 /* 32 */
	DF_SKINTEAMS        = 0x00000040 /* 64 */
	DF_MODELTEAMS       = 0x00000080 /* 128 */
	DF_NO_FRIENDLY_FIRE = 0x00000100 /* 256 */
	DF_SPAWN_FARTHEST   = 0x00000200 /* 512 */
	DF_FORCE_RESPAWN    = 0x00000400 /* 1024 */
	DF_NO_ARMOR         = 0x00000800 /* 2048 */
	DF_ALLOW_EXIT       = 0x00001000 /* 4096 */
	DF_INFINITE_AMMO    = 0x00002000 /* 8192 */
	DF_QUAD_DROP        = 0x00004000 /* 16384 */
	DF_FIXED_FOV        = 0x00008000 /* 32768 */
	DF_QUADFIRE_DROP    = 0x00010000 /* 65536 */
	DF_NO_MINES         = 0x00020000
	DF_NO_STACK_DOUBLE  = 0x00040000
	DF_NO_NUKES         = 0x00080000
	DF_NO_SPHERES       = 0x00100000

	ROGUE_VERSION_STRING = "08/21/1998 Beta 2 for Ensemble"
)

/*
 * ==========================================================
 *
 * ELEMENTS COMMUNICATED ACROSS THE NET
 *
 * ==========================================================
 */

//   ANGLE2SHORT(x) ((int)((x) * 65536 / 360) & 65535)
func SHORT2ANGLE(x int) float32 {
	return (float32(x) * (360.0 / 65536.0))
}

const (
	/* config strings are a general means of communication from
	 * the server to all connected clients. Each config string
	 * can be at most MAX_QPATH characters. */
	CS_NAME      = 0
	CS_CDTRACK   = 1
	CS_SKY       = 2
	CS_SKYAXIS   = 3 /* %f %f %f format */
	CS_SKYROTATE = 4
	CS_STATUSBAR = 5 /* display program string */

	CS_AIRACCEL    = 29 /* air acceleration control */
	CS_MAXCLIENTS  = 30
	CS_MAPCHECKSUM = 31 /* for catching cheater maps */

	CS_MODELS         = 32
	CS_SOUNDS         = (CS_MODELS + MAX_MODELS)
	CS_IMAGES         = (CS_SOUNDS + MAX_SOUNDS)
	CS_LIGHTS         = (CS_IMAGES + MAX_IMAGES)
	CS_ITEMS          = (CS_LIGHTS + MAX_LIGHTSTYLES)
	CS_PLAYERSKINS    = (CS_ITEMS + MAX_ITEMS)
	CS_GENERAL        = (CS_PLAYERSKINS + MAX_CLIENTS)
	MAX_CONFIGSTRINGS = (CS_GENERAL + MAX_GENERAL)
)

/* ============================================== */

/* entity_state_t->event values
 * entity events are for effects that take place reletive
 * to an existing entities origin.  Very network efficient.
 * All muzzle flashes really should be converted to events... */
const (
	EV_NONE            = 0
	EV_ITEM_RESPAWN    = 1
	EV_FOOTSTEP        = 2
	EV_FALLSHORT       = 3
	EV_FALL            = 4
	EV_FALLFAR         = 5
	EV_PLAYER_TELEPORT = 6
	EV_OTHER_TELEPORT  = 7
)

/* entity_state_t is the information conveyed from the server
 * in an update message about entities that the client will
 * need to render in some way */
type Entity_state_t struct {
	Number int /* edict index */

	Origin                                [3]float32
	Angles                                [3]float32
	Old_origin                            [3]float32 /* for lerping */
	Modelindex                            int
	Modelindex2, Modelindex3, Modelindex4 int /* weapons, CTF flags, etc */
	Frame                                 int
	Skinnum                               int
	Effects                               uint
	Renderfx                              int
	Solid                                 int /* for client side prediction, 8*(bits 0-4) is x/y radius */
	/* 8*(bits 5-9) is z down distance, 8(bits10-15) is z up */
	/* gi.linkentity sets this properly */
	Sound int /* for looping sounds, to guarantee shutoff */
	Event int /* impulse events -- muzzle flashes, footsteps, etc */
	/* events only go out for a single frame, they */
	/* are automatically cleared each frame */
}

func (T *Entity_state_t) Copy(other Entity_state_t) {
	T.Number = other.Number
	for i := 0; i < 3; i++ {
		T.Origin[i] = other.Origin[i]
		T.Angles[i] = other.Angles[i]
		T.Old_origin[i] = other.Old_origin[i]
	}
	T.Modelindex = other.Modelindex
	T.Modelindex2 = other.Modelindex2
	T.Modelindex3 = other.Modelindex3
	T.Modelindex4 = other.Modelindex4
	T.Frame = other.Frame
	T.Skinnum = other.Skinnum
	T.Effects = other.Effects
	T.Renderfx = other.Renderfx
	T.Solid = other.Solid
	T.Sound = other.Sound
	T.Event = other.Event
}

/* ============================================== */

/* player_state_t is the information needed in addition to pmove_state_t
 * to rendered a view.  There will only be 10 player_state_t sent each second,
 * but the number of pmove_state_t changes will be reletive to client
 * frame rates */
type Player_state_t struct {
	Pmove Pmove_state_t /* for prediction */

	Viewangles  [3]float32 /* for fixed views */
	Viewoffset  [3]float32 /* add to pmovestate->origin */
	Kick_angles [3]float32 /* add to view direction to get render angles */
	/* set by weapon kicks, pain effects, etc */

	Gunangles [3]float32
	Gunoffset [3]float32
	Gunindex  int
	Gunframe  int

	Blend   [4]float32 /* rgba full screen effect */
	Fov     float32    /* horizontal field of view */
	Rdflags int        /* refdef flags */

	Stats [MAX_STATS]int16 /* fast status bar updates */
}

func (T *Player_state_t) Copy(other Player_state_t) {
	T.Pmove.Copy(other.Pmove)
	for i := 0; i < 3; i++ {
		T.Viewangles[i] = other.Viewangles[i]
		T.Viewoffset[i] = other.Viewoffset[i]
		T.Kick_angles[i] = other.Kick_angles[i]
		T.Gunangles[i] = other.Gunangles[i]
		T.Gunoffset[i] = other.Gunoffset[i]
	}
	T.Gunindex = other.Gunindex
	T.Gunframe = other.Gunframe
	for i := 0; i < 4; i++ {
		T.Blend[i] = other.Blend[i]
	}
	T.Fov = other.Fov
	T.Rdflags = other.Rdflags
	for i := 0; i < MAX_STATS; i++ {
		T.Stats[i] = other.Stats[i]
	}
}

func (T *CvarT) Bool() bool {
	v, e := strconv.ParseFloat(T.String, 32)
	if e == nil && v != 0.0 {
		return true
	}
	return false
}

func (T *CvarT) Int() int {
	v, e := strconv.ParseFloat(T.String, 32)
	if e == nil {
		return int(v)
	}
	return 0
}

func (T *CvarT) Float() float32 {
	v, e := strconv.ParseFloat(T.String, 32)
	if e == nil {
		return float32(v)
	}
	return 0.0
}

func AngleVectors(angles, forward, right, up []float32) {

	angle := float64(angles[YAW]) * (math.Pi * 2 / 360)
	sy := float32(math.Sin(angle))
	cy := float32(math.Cos(angle))
	angle = float64(angles[PITCH]) * (math.Pi * 2 / 360)
	sp := float32(math.Sin(angle))
	cp := float32(math.Cos(angle))
	angle = float64(angles[ROLL]) * (math.Pi * 2 / 360)
	sr := float32(math.Sin(angle))
	cr := float32(math.Cos(angle))

	if forward != nil {
		forward[0] = cp * cy
		forward[1] = cp * sy
		forward[2] = -sp
	}

	if right != nil {
		right[0] = (-1*sr*sp*cy + -1*cr*-sy)
		right[1] = (-1*sr*sp*sy + -1*cr*cy)
		right[2] = -1 * sr * cp
	}

	if up != nil {
		up[0] = (cr*sp*cy + -sr*-sy)
		up[1] = (cr*sp*sy + -sr*cy)
		up[2] = cr * cp
	}
}

func LerpAngle(a2, a1, frac float32) float32 {
	if a1-a2 > 180 {
		a1 -= 360
	}

	if a1-a2 < -180 {
		a1 += 360
	}

	return a2 + frac*(a1-a2)
}

/*
 * Parse a token out of a string
 */
func COM_Parse(data string, index int) (string, int) {
	//  int c;
	//  int len;
	//  char *data;

	//  data = *data_p;
	//  len = 0;
	//  com_token[0] = 0;

	if index < 0 || index >= len(data) {
		return "", -1
	}

	skipwhite := true

	for skipwhite {
		skipwhite = false
		for index < len(data) && data[index] <= ' ' {
			index++
		}
		if index >= len(data) {
			return "", -1
		}

		/* skip // comments */
		if (data[index] == '/') && (data[index+1] == '/') {
			for index < len(data) && data[index] != '\n' {
				index++
			}
			skipwhite = true
		}
	}

	var token strings.Builder

	/* handle quoted strings specially */
	if data[index] == '"' {
		index++

		for {
			if index >= len(data) || data[index] == '"' {
				return token.String(), index + 1
			}
			token.WriteByte(data[index])
			index++
		}
	}

	/* parse a regular word */
	for {
		if index >= len(data) || data[index] <= ' ' {
			return token.String(), index
		}
		token.WriteByte(data[index])
		index++
	}
}

/*
 * =====================================================================
 *
 * INFO STRINGS
 *
 * =====================================================================
 */

/*
 * Searches the string for the given
 * key and returns the associated value,
 * or an empty string.
 */
func Info_ValueForKey(s, key string) string {

	split := strings.Split(s, "\\")
	index := 0
	for index < len(split)-1 {
		if split[index] == key {
			return split[index+1]
		}
		index += 2
	}

	return ""
}

/*
 * Generate a pseudorandom
 * integer >0.
 */
func Randk() int {
	return int(rand.Uint32())
}

type QCommon interface {
	Init() error
	IsDedicated() bool
	SetServerState(state int)
	ServerState() int
	Curtime() int
	Sys_Milliseconds() int
	QPort() int

	Com_VPrintf(print_level int, format string, a ...interface{})
	Com_Printf(format string, a ...interface{})
	Com_DPrintf(format string, a ...interface{})
	Com_Error(code int, format string, a ...interface{}) error

	Cvar_Get(var_name, var_value string, flags int) *CvarT
	Cvar_Set(var_name, value string) *CvarT
	Cvar_FullSet(var_name, value string, flags int) *CvarT
	Cvar_VariableBool(var_name string) bool
	Cvar_VariableInt(var_name string) int
	Cvar_VariableString(var_name string) string
	Cvar_Userinfo() string
	Cvar_ClearUserinfoModified()

	Cbuf_AddText(text string)
	Cbuf_Execute() error
	Cmd_AddCommand(cmd_name string, function func([]string, interface{}) error, arg interface{})
	Cmd_TokenizeString(text string, macroExpand bool) []string

	Netchan_OutOfBandPrint(net_socket Netsrc_t, adr Netadr_t, format string, a ...interface{}) error

	NET_GetPacket(sock Netsrc_t) (*Netadr_t, []byte)
	NET_SendPacket(sock Netsrc_t, data []byte, to Netadr_t) error

	FS_FOpenFile(name string, gamedir_only bool) (QFileHandle, error)
	LoadFile(path string) ([]byte, error)
}

type QClient interface {
	Init(common QCommon) error
	Frame(packetdelta, renderdelta, timedelta int, packetframe, renderframe bool) error
	IsVSyncActive() bool
	GetRefreshRate() int
}

type QServer interface {
	Init(common QCommon) error
	Frame(usec int) error
}
